# Маршрутизация

- [Введение](#Введение)
    - [Местоположение маршрутов](#Местоположение-маршрутов)
- [Правила маршрутизации](#Правила-маршрутизации)
    - [Переадрессация](#Переадрессация)
    - [Шаблон](#Шаблон)
    - [CSRF защита](#csrf)
- [Параметры маршрута](#Параметры-маршрута)
- [Именование маршрутов](#Именование-маршрутов)
- [Группы маршрутов](#Группы-маршрутов)
    - [Поддоменные маршруты](#Поддоменные-маршруты)
    - [Префикс пути](#Префикс-пути)
    - [Префикс имени](#Префикс-имени)
    - [Логическое значение](#Логическое-значение)
- [Привязка модели](#Привязка-модели)
- [Определение метода](#Определение-метода)
- [Получение маршрута](#Получение-маршрута)
</ul>

<a name="Введение"></a>
## Введение

Начиная с версии <strong>4.1.0</strong> MyUCP использует систему маршрутизации, она заменяет обычную систему адресов, где часть адреса указывала на директорию и название файла контроллера. Теперь вы можете сами указывать контроллер и метод который должен обработать нужный вам шаг пользователя.

<a name="Местоположение-маршрутов"></a>
### Местоположение маршрутов

Все маршруты хранятся в файле `app/routers.php`, там вы указавыаете правила маршрутизации.
Но так же существует `RouteService` который вызывается перед инициализацией маршрутов в `routes.php`.
Там вы можете создавать так же маршруты или например группы с файлами:

```php
<?php
/**
 * MyUCP
 */

namespace App\services;

use Router;

class RouteService
{
    public function __construct(Router $router)
    {

        Router::prefix('api', app()->appPath('api.php'));

    }
}
``` 

После кода выше, если вы создадите файл `app/api.php`, то там вы можете указывать маршруты и все они будут автоматчески
иметь префикс `/api`.

<a name="Правила-маршрутизации"></a>
## Правила маршрутизации

Все маршруты создаются на базе главного класа Маршрутизатора `Router` он имеет ряд статических методов которые будут вам доступны для работы.

Доступные правила маршрутизации:

```php
Router::get($uri, $callback);
Router::post($uri, $callback);
Router::put($uri, $callback);
Router::patch($uri, $callback);
Router::delete($uri, $callback);
Router::options($uri, $callback);
```

Но иногда вам нужно указать несколько разных методов доступа, например только через GET и DELETE,
для этого существуют два дополнительные метода: `match()` и `any` который позволит вам принимать все типы запросов.

```php
Router::match(['get', 'delete'], '/', function () {
    //
});

Router::any('foo', function () {
    //
});
```

Вторым аргументом для обычных методов вы указываете функцию которая будет вызвана при совпадении адреса маршрута
и текущего адреса приложения. Или же вы можете указать массив, который может так же иметь эту функцию, или указать
имя контроллера и метода которые должны быть вызваны.

```php
Router::get("/", function() {
	return "Hello World";
});

Router::get("/", "HomeController@welcome");
Router::get("/", ["uses" => "HomeController@welcome"]);
```

А так же вы можете указать контроллер или функцию после создания маршрута при помощи метода `uses()`


```php
Router::get("/")->uses("HomeController@welcome");
```

<a name="Переадрессация"></a>
### Переадрессация

Если вам нужно использовать маршрут в качестве переадрессации вы можете это сделать при помощи метода `redirect()`,
просто стоит указать адрес маршрута (с которого будет переадрессация) и адрес куда переадрессовывать.

```php
Router::redirect('/here', '/there');
```

Но так же вы можете указать в качестве цели переадрессации название маршрута который был создан.

```php
Router::any('/profile', 'UserController@profile')->name('profile');

Router::redirect('/user', 'profile');
```

В примере выше переадрессация произойдет с адреса `/user` на адрес маршрута `/profile`.

Но если у вас маршрут имеет параметры, вы можете указать их так же как бы указывали при создании обычной переадрессакции с маршрутом:

```php
Router::any('/page/{id:[0-9]+}', 'PageController@show')->name('page');

Router::redirect(['uri' => 'contacts', 'parameters' => [
    'id' => 1
]], 'page');
```

Все переадрессации при помощи данного метода происходят со статусом `302`, если вы хотите указать другой статус вы можете указать его в третьем параметре:

```php
Router::redirect('/here', '/there', 301);
```

<a name="Шаблон"></a>
### Шаблон

Если у вас есть статические страницы которые нужно вывести по конкретному адресу, вы можете использовать метод вывода шаблона `view`.
Этот метод как и обычная функция-помощник `view()` дает возможность компилировать <a href="/5.7/zara">Zara</a> шаблоны.

```php
Router::view('/contacts', 'contacts');
```

Вы так же можете передавать разные переменные в шаблоны для использования их внутри:

```php
Router::view('/contacts', 'contacts', ['email' => 'support@google.com']);
```

<a name="csrf"></a>
### CSRF защита

Для каждого маршрута вы можете включить CSRF-защиту, для этого нужно использовать метод `csrfVerify()`. После того как вы установили защиту
при обращении на маршрут нужно будет передавать специальный токен. Подробнее вы можете прочитать в разделе <a href="/5.7/csrf">CSRF защита</a>.

<a name="Параметры-маршрута"></a>
## Параметры маршрута

Не всегда страницы имеют постоянный адрес, например профиль пользователя у каждого будет разный,
что бы узнать какого именно пользователя открыт профиль нужно идентефицировать его. Но делая обычными
GET параметрами, это будет некрасиво выглядеть в виде адреса. Вы можете использовать параметры маршрута.

Для создания гибких и удобных параметров вы можете использовать регулярные выражения, которые помогут вам
более точно составлять адреса.

```php
Router::get("/user/{id:[0-9]+}", function($id) {
	return "User " . $id;
});
```

Как вы можете заметить создание параметра происходит легко, для этого нам нужно выделить его
фигурными скобками и указать название, через двоеточение необходимо указать правило (регулярное выражение)
для этого параметра, что бы фреймворк мог подобрать нужный адрес в нужный момент.

Все параметры поочередно передаются как аргументы функции которая указана в маршруте или методу контроллера.

<a name="Именование-маршрутов"></a>
## Именование маршрутов

Работая с маршрутами вам нужно будет выводить ссылки, или просто узнавать какую то информацию о маршруте.
Для этого есть функция именования маршрутов, которые мы потом может использовать для поиска того или инного маршрута.


Для указания имени маршрута вы можете использовать метод `name()` или ключ массива второго аргумента
`as`, и так и так вы укажете имя. Только например если вы уже указали имя и используете метод `name()`
то то что вы укажете в качестве параметра будет просто дополнением текущего имени, а не его изменением.

```php
Router::get("/", ["as" => "home"]);
Router::get("/")->name("home");
```

Теперь вы можете получить объект этого маршрута просто указав его имя в функции помощнике `route()`

```php
$route = route("home");
```

Или вы теперь сможете сгенерировать URL к этому маршруту, это может быть удобно когда адрес в процессе разрабокти
может измениться, и что бы его не искать и не менять везде вы можете просто сгенерировать к нему URL просто зная
его имя. Или вы можете переадресовать пользователя на него, просто передав его в функцию-помощник `redirect()`
в качестве аргумента.

```php
$url = app("url")->route("home");

// Переадресация
redirect(route("home"));
redirect()->route("home");
```

Это так же работает если в вашем маршруте есть параметры:

```php
Router::get("/user/{id:[0-9]+}", "UserController@profile")->name("profile");

//

$url = app("url")->route("profile", ["id" => 1]);

//

redirect(route("profile"), ["id" => 1]);
redirect()->route("home", ["id" => 1]);
```

Так же во время работы вы можете проверять текущий маршрут в качестве имени, просто используя метод `named()`:

```php
if(route()->named("profile")) {
	//
}
```

<a name="Группы-маршрутов"></a>
## Группы маршрутов

Иногда вам нужно применить фильтры или добавить какое то правило к роутам, и что бы не копировать этого вы можете
использовать группы. Это довольно простая конструкция, которая стала еще проще после обновления, даст вам возможность
создавать группы по нескольким категориям. Создание групп происходит при помощи метода `Router::group()` 
в аргументы которого передаются массивы с типом группы и с функцией содержимым.

```php
Router::group(['prefix' => 'admin'], function() {
    Router::get('/', function() {
        // Этот маршрут теперь будет доступен по адресу /admin/
    });

    Router::get('user/profile', function() {
        // А этот по адресу /admin/user/profile
    });
});
```

<a name="Поддоменные-маршруты"></a>
### Поддоменные маршруты
Вы так же можете работать с разными доменами или поддоменами.
Вы можете как указать сам домен для проверки, так и указать какой то параметр,
в итоге он будет доступен в вашем роутере в качестве аргумента для метода или для callback функции:

```php
Router::domain('api.myapp.com', function() {
    Router::get('users', function()
    {
        // Теперь этот адрес будет доступен только когда будет соотвествовать api.myapp.com
    });
});

Router::domain('{account:[a-zA-Z]+}.myapp.com', function() {
    Router::get('user/{id}', function($account, $id)
    {
        // Теперь этот адрес будет доступен только для доменов с подходящим правилом
    });
});
```

<a name="Префикс-пути"></a>
### Префикс пути
Вы можете указать префикс который будет обязательным для адресов который будут находиться
в этой группе.

```php
Router::prefix('admin', function() {
    Router::get('user', function() {
        // Этот адрес будет доступен теперь только по адресу /admin/user
    });
});
```

<a name="Префикс-имени"></a>
### Префикс имени

Так же вы можете отделить, например на категории, маршруты указывая им имена при помощи группы.
Указав группу с типом имени вы можете добавить в начало имени маршрута указанный префикс

```php
Router::name('users.', function() {
	Router::get('profile', function() {
		// Теперь имя этого маршрута будет users.profile
	})->name("profile");
});
```

<a name="Логическое-значение"></a>
### Логическое значение

Еще один тип групп это логическое значение, он принимает только `true` или `false`.
Вы можете это использовать например если у вас есть функция которая определяет состояние вашего приложения
и определяет доступ к определенным маршрутам, или например проверяет авторизацию пользователя.

```php
Router::condition(false, function() {
	Router::get("/works", "HomeController@works"); // Этот адрес не будет доступен
});
```

### Загрузка файла

Если вы вторым аргументом укажете вместо функции обратного вызова путь к файлу, то он будет загружен.
Это нужно для того что бы вы могли загружать дополнительные файлы с маршрутами.
Это может быть использовать при создании <a href="/docs/5.7/extensions">расширений</a>.

<a name="Привязка-модели"></a>
## Привязка модели

Для каждого роута вы можете указать модели которые потом будете использовать как обычно, вместо того что объявлять их уже в методе контроллера. Метод привязки похож с функцией-помощником <a href="/docs/5.7/helpers#model()">`model()`</a>

```php
Router::any("user/profile", "UserController@profile")->models("User");
```

<a name="Определение-метода"></a>
## Определение метода

Как вы можете заметить, при создании роута вы можете выбрать разные типы запросов, из обычных это `GET` и `POST`
но так же есть и другие, они не обрабатываються обычными веб-серверами, для этого нужно указать тип запроса который вы будете передавать,
при помощи скрытого поля `_method`

```php
<form action="/foo/bar" method="POST">
	<input type="hidden" name="_method" value="PUT">
</form>
```

Но в шаблонах Zara вы можете использовать директиву `@method` которая сама создат вам это поле.

```php
<form action="/foo/bar" method="POST">
    @method('PUT')
</form>
```

<a name="Получение-маршрута"></a>
## Получение маршрута

Как вы могли замтетить ранее мы использовали функцию `route()` для получения текущего маршрута
не указывая параметров, или получение оперделенного маршрута указывая его имя. Эта функция доступна в любом месте
и дает вам возможность обращаться к маршрутам и изменять их или получать нужную вам информацию.

Так же есть у класса `Route` есть два статических метода которые дадут вам возможность получить текущий
маршрут и просто текущее имя маршрута или вовсе проверить совпадает ли текущий маршрут с желаемым или его именем.

```php
$route = route(); // Получим текущий маршрут
$route = Route::current(); // Получим так же текущий маршрут

Route::currentRouteName(); // Вернет имя текущего маршрута
Route::isCurrent($route); // Вернет логическое значение проверив два маршрута (текущий и переданный)
Route::isCurrentName($name); // Вернет логическое значение проверив два маршрута по имени
```