# Маршрутизация

- [Введение](#Введение)
- [Правила маршрутизации](#Правила-маршрутизации)
- [Параметры маршрута](#Параметры-маршрута)
- [Именование маршрутов](#Именование-маршрутов)
- [Группы роутов](#Группы-роутов)
- [Привязка модели](#Привязка-модели)
- [Определение метода](#Определение-метода)
- [Получение маршрута](#Получение-маршрута)
</ul>

<a name="Введение"></a>
## Введение

Начиная с версии <strong>4.1.0</strong> MyUCP использует систему маршрутизации, она заменяет обычную систему адресов, где часть адреса указывала на директорию и название файла контроллера. Теперь вы можете сами указывать контроллер и метод который должен обработать нужный вам шаг пользователя.
Все маршруты в MyUCP находяться в `app/routers.php`.

<a name="Правила-маршрутизации"></a>
## Правила маршрутизации

Все маршруты создаються на базе главного класа Маршрутизатора `Router` он имеет ряд статических методов которые будут вам доступны для работы.

Доступные правила маршрутизации:

```php
Router::get($uri, $callback);
Router::post($uri, $callback);
Router::put($uri, $callback);
Router::patch($uri, $callback);
Router::delete($uri, $callback);
Router::options($uri, $callback);
```

Но иногда вам нужно указать несколько разных методов доступа, например только через GET и DELETE,
для этого существуют два дополнительные метода: `match()` и `any` который позволит вам принимать все типы запросов.
```php
Router::match(['get', 'delete'], '/', function () {
    //
});

Router::any('foo', function () {
    //
});
```

Но так же в новой версии были добавлены два новые метода: `redirect()` и `view()`.
Первый даст возможность вам совершать переадресацию на другой адрес без создания метода в контроллере
или создании функции, вы можете просто указать указать с которого нужно переадресовать, на какой.
Второй же метод даст возможность вывести вам сразу представление (шаблон) так же не создавая лишнего кода.
Для начала укажите адрес по которому он будет доступен, название шаблона (так же как и для функции `view()`,
после вы можете указать аргументы (переменные) которые будут доступны в шаблоне.

```php
Router::redirect('/here', '/there');

Router::view('/welcome', 'welcome');
Router::view('/welcome', 'welcome', ['name' => 'Elon']);
```

Вторым аргументом для обычных методов вы указываете функцию которая будет вызвана при совпадении адреса маршрута
и текущего адреса приложения. Или же вы можете указать массив, который может так же иметь эту функцию, или указать
имя контроллера и метода которые должны быть вызваны.

```php
Router::get("/", function() {
	return "Hello World";
});

Router::get("/", "HomeController@welcome");
Router::get("/", ["uses" => "HomeController@welcome"]);
```

А так же вы можете указать контроллер или функцию после создания маршрута при помощи метода `uses()`


```php
Router::get("/")->uses("HomeController@welcome");
```

<a name="Параметры-маршрута"></a>
## Параметры маршрута

Не всегда страницы имеют постоянный адрес, например профиль пользователя у каждого будет разный,
что бы узнать какого именно пользователя открыт профиль нужно идентефицировать его. Но делая обычными
GET параметрами, это будет некрасиво выглядеть в виде адреса. Вы можете использовать параметры маршрута.

Для создания гибких и удобных параметров вы можете использовать регулярные выражения, которые помогут вам
более точно составлять адреса.

```php
Router::get("/user/{id:[0-9]+}", function($id) {
	return "User " . $id;
});
```

Как вы можете заметить создание параметра происходит легко, для этого нам нужно выделить его
фигурными скобками и указать название, через двоеточение необходимо указать правило (регулярное выражение)
для этого параметра, что бы фреймворк мог подобрать нужный адрес в нужный момент.

Все параметры поочередно передаются как аргументы функции которая указана в маршруте или методу контроллера.

<a name="Именование-маршрутов"></a>
## Именование маршрутов

Работая с маршрутами вам нужно будет выводить ссылки, или просто узнавать какую то информацию о маршруте.
Для этого есть функция именования маршрутов, которые мы потом может использовать для поиска того или инного маршрута.


Для указания имени маршрута вы можете использовать метод `name()` или ключ массива второго аргумента
`as`, и так и так вы укажете имя. Только например если вы уже указали имя и используете метод `name()`
то то что вы укажете в качестве параметра будет просто дополнением текущего имени, а не его изменением.

```php
Router::get("/", ["as" => "home"]);
Router::get("/")->name("home");
```

Теперь вы можете получить объект этого маршрута просто указав его имя в функции помощнике `route()`

```php
$route = route("home");
```

Или вы теперь сможете сгенерировать URL к этому маршруту, это может быть удобно когда адрес в процессе разрабокти
может измениться, и что бы его не искать и не менять везде вы можете просто сгенерировать к нему URL просто зная
его имя. Или вы можете переадресовать пользователя на него, просто передав его в функцию-помощник `redirect()`
в качестве аргумента.

```php
$url = app("url")->route("home");

// Переадресация
redirect(route("home"));
redirect()->route("home");
```

Это так же работает если в вашем маршруте есть параметры:

```php
Router::get("/user/{id:[0-9]+}", "UserController@profile")->name("profile");

$url = app("url")->route("profile", ["id" => 1]);

redirect(route("profile"), ["id" => 1]);
redirect()->route("home", ["id" => 1]);
```

Так же во время работы вы можете проверять текущий маршрут в качестве имени, просто используя метод `named()`:

```php
if(route()->named("profile")) {
	//
}
```

<a name="Группы-роутов"></a>
## Группы роутов

Иногда вам нужно применить фильтры или добавить какое то правило к роутам, и что бы не копировать этого вы можете
использовать группы. Это довольно простая конструкция, которая стала еще проще после обновления, даст вам возможность
создавать группы по нескольким категориям. Создание групп происходит при помощи метода `Router::group()` 
в аргументы которого передаются массивы с типом группы и с функцией содержимым.

```php
Router::group(['prefix' => 'admin'], function() {
    Router::get('/', function()
    {
        // Этот маршрут теперь будет доступен по адресу /admin/
    });

    Router::get('user/profile', function()
    {
        // А этот по адресу /admin/user/profile
    });
});
```

### Поддоменные роуты
Вы так же можете работать с разными доменами или поддоменами.
Вы можете как указать сам домен для проверки, так и указать какой то параметр,
в итоге он будет доступен в вашем роутере в качестве аргумента для метода или для callback функции:

```php
Router::domain('api.myapp.com', function() {
    Router::get('users', function()
    {
        // Теперь этот адрес будет доступен только когда будет соотвествовать api.myapp.com
    });
});

Router::domain('{account:[a-zA-Z]+}.myapp.com', function() {
    Router::get('user/{id}', function($account, $id)
    {
        // Теперь этот адрес будет доступен только для доменов с подходящим правилом
    });
});
```

### Префикс пути
Вы можете указать префикс который будет обязательным для адресов который будут находиться
в этой группе.

```php
Router::prefix('admin', function() {
    Router::get('user', function() {
        // Этот адрес будет доступен теперь только по адресу /admin/user
    });
});
```

### Префикс имени

Так же вы можете отделить, например на категории, маршруты указывая им имена при помощи группы.
Указав группу с типом имени вы можете добавить в начало имени маршрута указанный префикс

```php
Router::name('users.', function() {
	Router::get('profile', function() {
		// Теперь имя этого маршрута будет users.profile
	})->name("profile");
});
```

### Логическое значение

Еще один тип групп это логическое значение, он принимает только `true` или `false`.
Вы можете это использовать например если у вас есть функция которая определяет состояние вашего приложения
и определяет доступ к определенным маршрутам, или например проверяет авторизацию пользователя.

```php
Router::condition(false, function() {
	Router::get("/works", "HomeController@works"); // Этот адрес не будет доступен
});
```

<a name="Привязка-модели"></a>
## Привязка модели

Для каждого роута вы можете указать модели которые потом будете использовать как обычно, вместо того что объявлять их уже в методе контроллера. Метод привязки похож с функцией-помощником `<a href="/docs/5.6/helpers#model()">model()</a>`

```php
Router::any("user/profile", "UserController@profile")->models("User");
```

<a name="Определение-метода"></a>
## Определение метода

Как вы можете заметить, при создании роута вы можете выбрать разные типы запросов, из обычных это `GET` и `POST`
но так же есть и другие, они не обрабатываються обычными веб-серверами, для этого нужно указать тип запроса который вы будете передавать,
при помощи скрытого поля `_method`

```php
<form action="/foo/bar" method="POST">
	<input type="hidden" name="_method" value="PUT">
</form>
```

Но в шаблонах Zara вы можете использовать директиву `@method` которая сама создат вам это поле.

```php
<form action="/foo/bar" method="POST">
    @method('PUT')
</form>
```

<a name="Получение-маршрута"></a>
## Получение маршрута

Как вы могли замтетить ранее мы использовали функцию `route()` для получения текущего маршрута
не указывая параметров, или получение оперделенного маршрута указывая его имя. Эта функция доступна в любом месте
и дает вам возможность обращаться к маршрутам и изменять их или получать нужную вам информацию.

Так же есть у класса `Route` есть два статических метода которые дадют вам возможность получить текущий
маршрут и просто текущее имя маршрута или вовсе проверить совпадает ли текущий маршрут с желаемым или его именем.

```php
$route = route(); // Получим текущий маршрут
$route = Route::current(); // Получим так же текущий маршрут

Route::currentRouteName(); // Вернет имя текущего маршрута
Route::isCurrent($route); // Вернет логическое значение проверив два маршрута (текущий и переданный)
Route::isCurrentName($name); // Вернет логическое значение проверив два маршрута по имени
```